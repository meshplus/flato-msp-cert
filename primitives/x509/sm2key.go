package x509

import (
	"encoding/asn1"
	"errors"
	"github.com/meshplus/crypto-gm"
	"math/big"
	//unsafe for linkname
	_ "unsafe"
)

//The private key generated by gmssl is slightly different from the private key of cfca
// so there are two similar structures, sm2PrivateKeyCFCA and sm2PrivateKeyGmssl
//GMT0010-2012 A.3
//GMT0009-2012 7.1
type sm2PrivateKeyCFCA struct {
	Version       int
	PrivateKey    *big.Int
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

type sm2PrivateKeyGmssl struct {
	Version       int
	PrivateKey    asn1.RawContent
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

//parseSMPrivateKey Parse guomi private key, support gmssl private key and cfca private key
// return the PrivateKey type.
// first try to resolve to the private key of type gmssl.
// if it fails, try to resolve to the private key of cfca.
//go:linkname parseSMPrivateKey github.com/meshplus/flato-msp-cert/primitives/internal.ParseSMPrivateKey
func parseSMPrivateKey(der []byte) (interface{}, error) {
	var privCFCA sm2PrivateKeyCFCA
	_, err := asn1.Unmarshal(der, &privCFCA)
	//if err is nil, parsing is successful
	if err == nil {
		if !privCFCA.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		sm2PrivateKey := new(gm.SM2PrivateKey).FromBytes(privCFCA.PrivateKey.Bytes())
		if sm2PrivateKey == nil {
			return nil, errors.New("sm2 private key is nil or too long")
		}
		bs := privCFCA.PublicKey.Bytes
		if len(bs) != 65 {
			return nil, errors.New("sm2 public key is not 65 bytes")
		}
		pk := sm2PrivateKey.PublicKey.FromBytes(bs)
		if pk == nil {
			return nil, errors.New("sm2 public key is not 65 bytes is not in curve")
		}
		sm2PrivateKey.PublicKey.Curve = gm.GetSm2Curve()
		return sm2PrivateKey, nil
	}

	var privGmssl sm2PrivateKeyGmssl
	_, err = asn1.Unmarshal(der, &privGmssl)
	//if err is nil, parsing is successful
	if err == nil {
		if !privGmssl.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		sm2PrivateKey := new(gm.SM2PrivateKey).FromBytes(privGmssl.PrivateKey)
		if sm2PrivateKey == nil {
			return nil, errors.New("sm2 private key is nil or too long")
		}
		bs := privGmssl.PublicKey.Bytes
		if len(bs) != 65 {
			return nil, errors.New("sm2 public key is not 65 bytes")
		}
		pk := sm2PrivateKey.PublicKey.FromBytes(bs)
		if pk == nil {
			return nil, errors.New("sm2 public key is not 65 bytes is not in curve")
		}
		sm2PrivateKey.PublicKey.Curve = gm.GetSm2Curve()
		return sm2PrivateKey, nil
	}

	return nil, errors.New("is not SM Private key")
}

//go:linkname marshalSMPrivateKey github.com/meshplus/flato-msp-cert/primitives/internal.MarshalSMPrivateKey
func marshalSMPrivateKey(x *gm.SM2PrivateKey) ([]byte, error) {
	xy := x.Public()
	xyBytes, err := xy.(*gm.SM2PublicKey).Bytes()
	if err != nil {
		return nil, err
	}
	priv := sm2PrivateKeyCFCA{
		Version:       1, //GMT0010-2012 A.3
		PrivateKey:    new(big.Int).SetBytes(x.K[:]),
		NamedCurveOID: oidNamedCurveP256Sm2,
		PublicKey:     asn1.BitString{Bytes: xyBytes},
	}
	return asn1.Marshal(priv)
}
