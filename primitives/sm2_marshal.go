package primitives

import (
	"encoding/asn1"
	"errors"
	gm "github.com/meshplus/crypto-gm"
	"math/big"
)

//MarshalSMPrivateKey Marshal guomi private key, support gmssl private key and cfca private key
func marshalSMPrivateKey(x *gm.SM2PrivateKey) ([]byte, error) {
	pub, _ := x.PublicKey.Bytes()
	key := &sm2PrivateKeyCFCA{
		Version:       1,
		PrivateKey:    new(big.Int).SetBytes(x.K[:]),
		NamedCurveOID: oidNamedCurveP256Sm2,
		PublicKey: asn1.BitString{
			Bytes:     pub,
			BitLength: len(pub) * 8,
		},
	}
	return asn1.Marshal(*key)
}

var (
	oidNamedCurveP256Sm2 = asn1.ObjectIdentifier{1, 2, 156, 10197, 1, 301}
)

//The private key generated by gmssl is slightly different from the private key of cfca
// so there are two similar structures, sm2PrivateKeyCFCA and sm2PrivateKeyGmssl
type sm2PrivateKeyCFCA struct {
	Version       int
	PrivateKey    *big.Int
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

type sm2PrivateKeyGmssl struct {
	Version       int
	PrivateKey    asn1.RawContent
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

//ParseSMPrivateKey Parse guomi private key, support gmssl private key and cfca private key
//return the gmx509.PrivateKey type.
//first try to resolve to the private key of type gmssl.
//if it fails, try to resolve to the private key of cfca.
func parseSMPrivateKey(der []byte) (*gm.SM2PrivateKey, error) {
	var privGmssl sm2PrivateKeyGmssl
	var privCFCA sm2PrivateKeyCFCA
	_, err := asn1.Unmarshal(der, &privGmssl)
	//if err is nil, parsing is successful
	if err == nil {
		if !privGmssl.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		sm2PrivateKey := new(gm.SM2PrivateKey).FromBytes(privGmssl.PrivateKey)
		if sm2PrivateKey == nil {
			return nil, errors.New("sm2 private key is nil or too long")
		}
		bs := privGmssl.PublicKey.Bytes
		if len(bs) != 65 {
			return nil, errors.New("sm2 public key is not 65 bytes")
		}
		pk := sm2PrivateKey.PublicKey.FromBytes(bs)
		if pk == nil {
			return nil, errors.New("sm2 public key is not 65 bytes is not in curve")
		}
		sm2PrivateKey.PublicKey.Curve = gm.GetSm2Curve()
		return sm2PrivateKey, nil
	}

	_, err = asn1.Unmarshal(der, &privCFCA)
	//if err is nil, parsing is successful
	if err == nil {
		if !privCFCA.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
			return nil, errors.New("is not SM Private key")
		}
		sm2PrivateKey := new(gm.SM2PrivateKey).FromBytes(privCFCA.PrivateKey.Bytes())
		if sm2PrivateKey == nil {
			return nil, errors.New("sm2 private key is nil or too long")
		}
		bs := privCFCA.PublicKey.Bytes
		if len(bs) != 65 {
			return nil, errors.New("sm2 public key is not 65 bytes")
		}
		pk := sm2PrivateKey.PublicKey.FromBytes(bs)
		if pk == nil {
			return nil, errors.New("sm2 public key is not 65 bytes is not in curve")
		}
		sm2PrivateKey.PublicKey.Curve = gm.GetSm2Curve()
		return sm2PrivateKey, nil
	}

	return nil, errors.New("is not SM Private key")
}
