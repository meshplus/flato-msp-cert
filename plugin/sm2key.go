package plugin

import (
	"encoding/asn1"
	"errors"
	"github.com/meshplus/crypto"
	gm "github.com/meshplus/crypto-gm"

	//unsafe for linkname
	"math/big"
)

//The private Key generated by gmssl is slightly different from the private Key of cfca
// so there are two similar structures, sm2PrivateKeyCFCA and sm2PrivateKeyGmssl
/*
 *  GMT0009-2012 7.1
 *  SM2PrivateKey::=INTEGER
 *  SM2PublicKey::=BIT STRING content is 04||X||Y, length is 65 bytes
 *
 *  GMT0010-2012 A.3, same as X962
 *  ECPrivateKey{CURVES:IOSet)::=SEQUENCE{
 *      version INTEGER{ecPrivkeyVer1(1)}(ecPrivkeyVer1),
 *      privateKey SM2PrivateKey,
 *      parameters [0] Parameters{{IOSet}} OPTIONAL,
 *      publicKey [1] SM2PublicKey
 *  }
 **/

type sm2PrivateKey struct {
	Version       int
	PrivateKey    []byte
	NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
	PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
}

//ParseSMPrivateKey Parse guomi private Key, support gmssl private Key and cfca private Key
// return the PrivateKey type.
// first try to resolve to the private Key of type gmssl.
// if it fails, try to resolve to the private Key of cfca.
func ParseSMPrivateKey(der []byte) (*gm.SM2PrivateKey, error) {
	return parseSMprivateKeyWithSwitch(der, true)
}

func parseSMprivateKeyWithSwitch(der []byte, assertOID bool) (*gm.SM2PrivateKey, error) {
	var priv sm2PrivateKey
	if _, err := asn1.Unmarshal(der, &priv); err != nil {
		var privWrong struct {
			Version       int
			PrivateKey    *big.Int
			NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
			PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
		}
		_, err := asn1.Unmarshal(der, &privWrong)
		if err != nil {
			return nil, errors.New("is not SM Private Key")
		}
		priv.PublicKey = privWrong.PublicKey
		priv.PrivateKey = privWrong.PrivateKey.Bytes()
		priv.NamedCurveOID = privWrong.NamedCurveOID
		priv.Version = privWrong.Version
	}
	//if err is nil, parsing is successful
	if assertOID && len(priv.NamedCurveOID) < 0 {
		return nil, errors.New("unknown Private Key curve type, maybe not sm2")
	}
	if len(priv.NamedCurveOID) > 0 && !priv.NamedCurveOID.Equal(oidNamedCurveP256Sm2) {
		return nil, errors.New("is not SM Private Key")
	}
	sm2PrivateKeyStruct := new(gm.SM2PrivateKey)
	if sm2PrivateKeyStruct.FromBytes(priv.PrivateKey, crypto.Sm2p256v1) != nil {
		return nil, errors.New("sm2 private Key is nil or too long")
	}
	sm2PrivateKeyStruct.CalculatePublicKey()
	bs := priv.PublicKey.Bytes
	if len(bs) != 65 {
		return nil, errors.New("sm2 public Key is not 65 bytes")
	}
	pk := sm2PrivateKeyStruct.PublicKey
	if pk.FromBytes(bs, crypto.Sm2p256v1) != nil {
		return nil, errors.New("sm2 public Key is not 65 bytes nor in curve")
	}
	sm2PrivateKeyStruct.PublicKey.Curve = gm.GetSm2Curve()
	return sm2PrivateKeyStruct, nil
}

//MarshalSMPrivateKey marshal sm2 private key
func MarshalSMPrivateKey(x *gm.SM2PrivateKey, withPKCS8 bool) ([]byte, error) {
	xy := &x.PublicKey
	xyBytes, err := xy.Bytes()
	if err != nil {
		return nil, err
	}
	priv := sm2PrivateKey{
		Version:       1, //GMT0010-2012 A.3
		PrivateKey:    new(big.Int).SetBytes(x.K[:]).Bytes(),
		NamedCurveOID: oidNamedCurveP256Sm2,
		PublicKey:     asn1.BitString{Bytes: xyBytes},
	}
	if withPKCS8 {
		priv.NamedCurveOID = nil
	}
	return asn1.Marshal(priv)
}
